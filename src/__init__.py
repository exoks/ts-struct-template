#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚£¶‚£¥‚£∂‚£æ‚£ø‚£∂‚£∂‚£∂‚£∂‚£¶‚£§‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚°∂‚†ª‚†õ‚†ü‚†ã‚†â‚†Ä‚†à‚†§‚†¥‚†∂‚†∂‚¢æ‚£ø‚£ø‚£ø‚£∑‚£¶‚†Ñ‚†Ä‚†Ä‚†Ä             ìêì  __init__.py ìêî           
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†î‚†ã‚†Ä‚†Ä‚†§‚†í‚†í‚¢≤‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£§‚£§‚£¨‚£Ω‚£ø‚£ø‚£ø‚£∑‚£Ñ‚†Ä‚†Ä
#  ‚†Ä‚†Ä‚†Ä‚£Ä‚£é‚¢§‚£∂‚£æ‚†Ö‚†Ä‚†Ä‚¢Ä‚°§‚†è‚†Ä‚†Ä‚†Ä‚††‚£Ñ‚£à‚°ô‚†ª‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£¶‚†Ä       Dev: oezzaou </var/spool/mail/oezzaou>
#  ‚¢Ä‚†î‚†â‚†Ä‚†ä‚†ø‚†ø‚£ø‚†Ç‚††‚†¢‚£§‚†§‚£§‚£º‚£ø‚£∂‚£∂‚£§‚£ù‚£ª‚£∑‚£¶‚£ç‚°ª‚£ø‚£ø‚£ø‚£ø‚°Ä
#  ‚¢æ‚£æ‚£Ü‚£§‚£§‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á
#  ‚†Ä‚†à‚¢ã‚¢π‚†ã‚†â‚†ô‚¢¶‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á       Created: 2025/07/24 16:59:34 by oezzaou
#  ‚†Ä‚†Ä‚†Ä‚†ë‚†Ä‚†Ä‚†Ä‚†à‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†á       Updated: 2025/07/24 17:09:43 by oezzaou
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°á‚†Ä‚†Ä‚¢Ä‚£æ‚£ø‚£ø‚†ø‚†ü‚†õ‚†ã‚†õ‚¢ø‚£ø‚£ø‚†ª‚£ø‚£ø‚£ø‚£ø‚°ø‚†Ä
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†á‚†Ä‚¢†‚£ø‚£ü‚£≠‚£§‚£∂‚£¶‚£Ñ‚°Ä‚†Ä‚†Ä‚†à‚†ª‚†Ä‚†ò‚£ø‚£ø‚£ø‚†á‚†Ä
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†±‚†§‚†ä‚†Ä‚¢Ä‚£ø‚°ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚†è‚†Ä‚†Ä                             ìÜ©‚ôïìÜ™
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ñ‚†Ä‚†Ä‚†Ä‚†ò‚¢ß‚°Ä‚†Ä‚†Ä‚†∏‚£ø‚£ø‚£ø‚†ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ê‚†ã‚†Ä‚†Ä‚†Ä                     ìÑÇ oussama ezzaouìÜÉ
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†Ñ‚£Ä‚°Ä‚†∏‚†ì‚†Ä‚†Ä‚†Ä‚††‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
# INFO:-------------------------------------------------------------------------
# - When Adding __init__.py, you tell the python that this directory is package
#   python start seeing directory as package, so everything inside becomes
#   'importable'

# ===[ QUESTION:]==============================================================
# - Why can we just import the module inside the directory by it's path,
#   like in c, c++
# You're absolutely right to feel this is a bit strange ‚Äî Python's import system works very differently from C/C++, and it's rooted in Python's philosophy and design decisions.
# Let‚Äôs walk through why this is the case, and why Python doesn't allow path-based importing like C/C++'s #include "file.h":
# üöÄ Why Python Doesn't Import by File Path Like C/C++
# üîó 1. Python is interpreted, not compiled
#
#     In C/C++, #include literally copies the contents of a file into another during preprocessing.
#
#     In Python, import is not textual inclusion ‚Äî it's a runtime operation.
#
#     Python loads and executes modules dynamically using its module resolution system.
#
# üóÇÔ∏è 2. Python uses package/module hierarchy, not file paths
#
# Python modules are resolved using:
#
#     sys.path (a list of search directories)
#
#     Package structure (__init__.py)
#
#     Module names (not paths)
#
# Example:
#
# from utils import math_tools
#
# Python looks:
#
#     In current dir
#
#     In PYTHONPATH
#
#     In site-packages
#
#     Inside packages (if __init__.py is present)
#
# üìÅ It‚Äôs not "look in /path/to/utils/math_tools.py" ‚Äî it‚Äôs "look for a 
#    package named utils, and a module named math_tools inside it."
# ‚ùå Why Not Allow from /some/path/file.py import foo?
#
# It seems logical, but has issues:
#
#     Breaks portability
#
#     Breaks Python‚Äôs ability to cache and reuse modules
#
#     Would tightly couple scripts to file structure
#
#     Introduces security risks (importing arbitrary paths)
#
#     Harder to lint, debug, test, and introspect
#
# ‚úÖ What you can do if you really want path-based importing
#
# Python has workarounds, but they‚Äôre advanced:
# üß™ Option 1: Manually extend sys.path
#
# import sys
# sys.path.append("/path/to/my/modules")
# from my_module import something
#
#     ‚úÖ Works but not clean ‚Äî breaks in production or multi-platform.
#
# üß™ Option 2: Use importlib.util (dynamic import by path)
#
# import importlib.util
#
# spec = importlib.util.spec_from_file_location("my_module", "/path/to/my_module.py")
# module = importlib.util.module_from_spec(spec)
# spec.loader.exec_module(module)
#
# module.some_function()
#
#     ‚úÖ Full path import! But clunky and not beginner-friendly.
#
# üß† Philosophy: Python favors namespaces and packages over file paths
#
# Python's import system is designed to:
#
#     Be safe
#
#     Promote modularity
#
#     Encourage readable and maintainable code
#
#     Avoid C-style spaghetti code from #include abuse
#
# üî• TL;DR
# Feature	C/C++	Python
# Include by file path	#include "file.h"	‚ùå Not supported directly
# Import by module name	‚ùå	‚úÖ Standard way (import x)
# Can override search paths	-I compiler flag	sys.path or PYTHONPATH
# Copy/paste code into source	#include	‚ùå Not how import works
# Portable across systems	‚ùå Often path-specific	‚úÖ Yes
